

module FinalCutServer
  
  # 
  # The Client class provides the means by which the FCS library interacts with Final Cut Server,
  # utilizing the +fcsvr_client+ command-line tool.
  #
  class Client
    
    #
    # A custom exception thrown when a command times out.
    #
    class ClientTimeout < RuntimeError
      attr_reader :command, :bytes_read
      
      def initialize(command = nil, bytes_read = nil)
        @command = command
        @bytes_read = bytes_read
      end
    end
    
    # We're going to use 'clone' as an autogenerated method, so remove the standard
    # clone method first
    undef_method :clone
    
    # Add accessor methods for a couple of class variables
    class << self
      attr_accessor :fcs_binary, :fcs_timeout, :ssh_host, :ssh_username, :ssh_private_key_file
    end
    
    # Default values
    self.fcs_binary  = "/Library/Application\\ Support/Final\\ Cut\\ Server/Final\\ Cut\\ Server.bundle/Contents/MacOS/fcsvr_client"
    self.fcs_timeout = 30
    self.ssh_host = "localhost"
    self.ssh_username = "admin"
    self.ssh_private_key_file = "~/.ssh/id_rsa"
    
    # find out how many bytes were read during the last command.
    attr_accessor :bytes_read, :last_call
    
    def initialize
      self.bytes_read = 0
      self.last_call = ""
    end
    
    # Overridden to turn +client.something(options, arg1, arg2)+ into a call to
    # +client.run('something', options, [arg1, arg2])+. See run() for details.
    def method_missing(cmd, options = {}, *args)
      run(cmd, options, *args)
    end
    
    protected
    
    #
    # Run the given fcsvr_client command with the specified arguments and return
    # the result as a String.
    #
    # - cmd:      The fcsvr_client command to run.
    # - options:  An optional Hash of Ruby-style options, to be converted into 
    #             command-line options.
    # - args:     An optional list of general arguments, to be appended to the 
    #             command-line invocation.
    #
    # Returns String.
    #
    # ==== Examples
    #   client.list_groups({:maxcount => 10}, "--xml")
    #   client.getmd({}, '/asset/352')
    #   client.list_parent_links({:xml => true}, '/asset/352')
    #
    def run(cmd, options, args = [])
      # If the options contain a :sudo option, remove it record it's value for use in the call.
      sudo = options.delete(:sudo)
      # if sudo isn't defined then it's assumed to be false
      sudo = "" if sudo.nil?
      
      # If the options contain a :search_hash option, remove it and record it.
      search_hash = options.delete(:search_hash)
      #Convert the search hash to a xml search if it's found
      search_xml = create_search_xml(search_hash) unless search_hash.nil?
      if search_xml.nil?
        xmlcrit = ""
      else
        xmlcrit = "--xmlcrit" 
      end
      # pull out some properly formatted (and applicable) options from the option hash
      opt_args = transform_options(options)
      # single-quote any arguments which aren't the 'end of argument list' marker (--)
      ext_args = args.map { |a| a == '--' ? a : "#{a}" }
      
      # build the call and print it if debugging
      call = "#{sudo.to_s} #{Client.fcs_binary} #{cmd.to_s} #{xmlcrit} #{(opt_args + ext_args).join(' ')}"
      puts call if FinalCutServer.debug
      self.last_call = call
      
      # run the call via the command-line shell, printing the response in debug mode
      if search_xml.nil?
        response = ssh_sh(call)
      else
        response = ssh_sh(call, search_xml)
      end
      
      puts response if FinalCutServer.debug
      
      # return the response
      response
    end

    #
    # Creates a properly formatted search xml string taking a hash of the correct form.
    # Primary purpose is to allow a json search ctieria string to be passed in and then
    # used for searching.
    #
    def create_search_xml(search_terms)
      @match_types = {"interesect" => {"id" => 3, "name" => "CRIT_INTERSECT"}, "value" => {"id" => 1, "name" => "CRIT_CMP_VALUE"}}

      raise "Search was malformed.   Empty!" if search_terms.nil?
      raise "Search was malformed.   No outer search." if search_terms["search"].nil?
      raise "Search was malformed.   No search type found!" if search_terms["search"]["type"].nil?
      raise "Search was malformed.   No criteria were specified" if search_terms["search"]["criteria"].nil? || search_terms["search"]["criteria"].empty?

      doc = REXML::Document.new "<session><values/></session>"

      doc << REXML::XMLDecl.new

      crit_type_value = REXML::Element.new "value"
      crit_type_value.attributes["id"] = "CRIT_TYPE"
      crit_type_value.add_element "int"
      crit_type_value.elements["int"].text = @match_types[search_terms["search"]["type"]]["id"]

      doc.elements["session/values"].add_element crit_type_value

      crit_params_wrapper_value = REXML::Element.new "value"
      crit_params_wrapper_value.attributes["id"] = @match_types[search_terms["search"]["type"]]["name"]
      crit_params_wrapper_value.add_element "valuesList"

      doc.elements["session/values"].add_element crit_params_wrapper_value

      search_terms["search"]["criteria"].each do |crit|    
        crit_param_values = REXML::Element.new "values"
        next_element = 1

        if crit["offset"] != 0
          crit_param_values.add_element "value"
          crit_param_values.elements["value"].attributes['id'] = "CRIT_CMP_VALUE_OFFSET"
          crit_param_values.elements["value"].add_element "int"
          crit_param_values.elements["value/int"].text = crit["offset"]
          next_element += 1
        end

        crit_param_values.elements.add REXML::Element.new "value"
        crit_param_values.elements[next_element, "value"].attributes['id'] = crit["offset"] != 0 ? "CRIT_CMP_CALC_VALUE" : "CRIT_CMP_VALUE"
        crit_param_values.elements[next_element, "value"].add_element "value"
        crit_param_values.elements[next_element, "value"].elements['value'].attributes['id'] = crit["name"]
        crit_param_values.elements[next_element, "value"].elements['value'].add_element crit["data_type"]
        crit_param_values.elements[next_element, "value"].elements['value/#{crit["data_type"]}'].text = crit["value"]
        next_element += 1

        crit_param_values.elements.add REXML::Element.new "value"
        crit_param_values.elements[next_element, "value"].attributes['id'] = "CRIT_CMP_OP"
        crit_param_values.elements["value[@id='CRIT_CMP_OP']"].add_element "atom"
        crit_param_values.elements["value[@id='CRIT_CMP_OP']/atom"].text = crit["op"]
        next_element += 1    

        crit_param_values.elements.add REXML::Element.new "value"
        crit_param_values.elements[next_element, "value"].attributes['id'] = "CRIT_TYPE"
        crit_param_values.elements["value[@id='CRIT_TYPE']"].add_element "int"
        crit_param_values.elements["value[@id='CRIT_TYPE']/int"].text = @match_types["value"]["id"]

        doc.elements["session/values/value[@id = 'CRIT_INTERSECT']/valuesList"].add_element crit_param_values
      end

      return doc
    end

    #
    # Performs the pre-built command-line invocation as sh(),  but doesn't use a timeout.
    # It also uses a net-ssh channel to reach the host where fcsvr_client is located
    # It also doesn't catch any exceptions raised by the IO methods.
    #
    # - command: The command to be passed to the shell, as a String.
    #
    # Returns String.
    #
    def ssh_sh(command, search_xml = nil)
      Net::SSH.start(self.class.ssh_host, self.class.ssh_username, {:verbose => Logger::FATAL, :keys => Array[self.class.ssh_private_key_file], :encryption => "3des-cbc", :hmac => "hmac-md5", :auth_methods => Array["publickey"]}) do |ssh|
        ssh.open_channel do |channel|
          channel.exec(command) do |ch, success|
            puts "Failure to execute command" unless success
            
            ret = ""
            
            channel.on_data do |ch, data|
              @bytes_read += data.size
              ret << data
            end
            
            channel.on_extended_data do |ch, type, data|
              error_data_read << data
            end
            
            unless search_xml.nil?
              channel.send_data(search_xml.to_s)
              channel.eof!
            end
            
            channel.on_close do |ch|
              if ret.empty?
                @bytes_read += ret.size
                ret = error_data_read
                return ret
              else
                return ret
              end
            end
          end
        end
        ssh.loop
      end
    end
    
    public
    
    #
    # Transform Ruby style options into fcsvr_client command line options
    # - options: Hash of Ruby-style options
    #
    # Returns String[], e.g. +["--version=10", "--noheader", "--xml"]+
    #
    def transform_options(options)
      args = []
      options.keys.each do |opt|
        if opt.to_s.size == 1   # single-character options
          # a value of 'true' means the option has no parameters (i.e. '-h')
          if options[opt] == true
            args << "-#{opt}"
          else
            val = options.delete(opt)   # retrieve value and remove from hash
            args << "-#{opt.to_s} '#{val}'"
          end
        else  # multi-character options
          if options[opt] == true
            args << "--#{opt.to_s}"
          else
            val = options.delete(opt)
            args << "--#{opt.to_s} '#{val}'"
          end
        end
      end
      args  # return the argument array
      
    end
    
  end # end class Client
  
end # end module FinalCutServer